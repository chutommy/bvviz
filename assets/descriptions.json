{
  "style_hide_header": "<style> header {visibility: hidden} </style>",
  "style_hide_footer": "<style> footer {visibility: hidden;} </style>",
  "style_hide_view_fullscreen": "<style> button[title='View fullscreen'] {visibility: hidden} </style>",
  "err_secret_str_length": "The length of the secret string ({str_len}) cannot be 0 or cannot exceed the number of qubits in the backend simulator minus one ({qu_num} - 1).",
  "err_secret_str_value": "The secret string should only consist of 0s and 1s.",
  "info_wait_compute": "Please wait while the experiment is running. This may take some time to complete.",
  "info_wait_render": "Rendering charts and plots...",
  "warn_failure": "Execution failed due to invalid configuration settings. Please ensure all values are valid and fully compatible with the selected backend before taking the next step.",
  "text_introduction": "Welcome to my web application for visualizing the Bernstein-Vazirani algorithm! This application aims to provide a user-friendly interface for those who are interested in learning more about quantum computing and its limitations. The Bernstein-Vazirani algorithm is a fundamental quantum algorithm that serves as an excellent example to showcase the potential benefits and downfalls of quantum computing. My goal is to provide users with a simple yet informative way to understand quantum informatics by visualizing the results of the Bernstein-Vazirani algorithm. We hope that this application can be used as a valuable resource for those who are new to quantum computing and want to gain a deeper understanding of its capabilities and limitations.",
  "text_bv_explanation": "The Bernstein-Vazirani problem is a well-known problem in quantum computing that demonstrates the potential speedup of quantum algorithms over classical algorithms. In this problem, we are given a black box function $f:{0,1}^n \\to {0,1}$, which takes an $n$-bit string as input and returns either 0 or 1. The function is promised to have a special property: it can be represented as the dot product of its input with some unknown $n$-bit string $s \\in {0,1}^n$, i.e., $f(x) = s\\cdot x \\bmod 2$. The goal is to determine the value of $s$ by querying the function $f$.\n\nThe classical approach to this problem requires $n$ queries to the function $f$, and the time complexity is $O(n)$. On the other hand, the quantum approach can solve the problem using only one query to $f$, and the time complexity is $O(1)$. This remarkable speedup is achieved by using quantum parallelism and interference to extract information about $s$ from a single query. Specifically, the quantum algorithm uses a Hadamard transform to put the input qubits into a superposition of all possible inputs, applies the black box function $f$, and then applies another Hadamard transform to extract information about $s$. The resulting quantum state can be measured to obtain the value of $s$ with high probability.\n\nThe Bernstein-Vazirani problem is a simple but powerful example of the potential of quantum computing to solve problems more efficiently than classical computers.",
  "text_disclaimer": "Please note that while the visualization you've seen allowed for higher error rates, the Bernstein-Vazirani protocol itself has been shown to be relatively robust to errors, even with noisy intermediate-scale quantum (NISQ) devices. However, it should be emphasized that the protocol relies on a relatively small number of gates, and even with significantly lower error rates, the differences in the results can still show that quantum computations on a large scale remain unreliable. As quantum computing technology continues to develop, efforts are being made to address these issues and improve the reliability of large-scale quantum computations.",
  "text_circuit_layout": "This is the layout of a circuit transpiled for the target backend. You can see a visual representation of the physical qubits that were used and how they were connected, providing important information for understanding how the quantum circuit is mapped onto the hardware.\n\nBy analyzing the layout, you can gain insights into the performance of the circuit on the target hardware, as well as the potential for optimization or further refinement. Overall, the layout provides a valuable tool for understanding and visualizing the complex interactions between the quantum circuit and the underlying hardware.",
  "text_error_map": "An error map provides a visualization of the error rates for each qubit and gate in a quantum computing backend. By examining the error map, users can identify the regions of the hardware that may be more prone to errors, and adjust their configuration settings accordingly to optimize the performance of their quantum circuits. The error rates are represented using a color scale, with higher error rates indicated by lighter colors.\n\nIt is important to note that the error map shown here is for the default configuration of the backend, and may differ depending on the specific configuration settings chosen by the user.",
  "text_quantum_circuit": "In the plot, the qubits are represented as horizontal lines, with the gates or operations acting on them placed vertically at the appropriate locations along the lines. The order of the gates indicates the order of their application in the circuit, and the type of gate is shown by its label, shape and color.",
  "text_measurements": "The counts chart is a type of visualization used to display the frequency of outcomes for a quantum algorithm experiment. The chart consists of a series of bars, with each bar representing a specific measurement result. The height of each bar corresponds to the frequency of that outcome, and the total area under the bars adds up to the total number of measurements performed.\n\nThe counts chart can be useful for identifying patterns and trends in the data, such as the presence of peaks or clusters in the distribution of counts. It can also be used to compare the results of different experiments or to analyze the impact of changing experimental parameters, such as the number of qubits or gates used.",
  "text_error_rate": "The pie chart represents the proportion of correct and incorrect measurements obtained during the experiment.\n\nIt's important to note that even if the proportion of correct measurements is relatively low, it doesn't necessarily mean that the targeted value is unattainable. This is because the correct measurements correspond to a single value, whereas the incorrect measurements are spread out across many possible values.\n\nThe bar chart next to the pie chart shows the number of incorrect measured bits among the incorrect measurements.",
  "help_quantum_system": "Choose a quantum simulator backend for the experiment. The number next to each backend name indicates the maximum number of qubits the simulator can handle.",
  "help_shots": "Enter the number of times the circuit will be executed, providing statistical results from multiple measurements. Consider a higher number of shots for better accuracy, but note that it will also increase the computational time.",
  "help_simulator_seed": "Seed to control simulator sampling.",
  "help_secret_str": "Enter a secret string for the Bernstein-Vazirani algorithm, which determines the value to be discovered using the quantum circuit. This string must consist of 0s and 1s. Note that the length of the secret string must not exceed the number of qubits in the backend simulator minus one, as one qubit is reserved for the ancilla qubit.",
  "help_reset_err": "Specify the error rate for qubit reset operation, which is the probability that a qubit fails to be reset to the initial state.",
  "help_measurement_err": "Specify the error rate for the measurement operation, which is the probability of obtaining an incorrect outcome after performing a measurement on a single qubit.",
  "help_single_gate_err": "Specify the error rate for single-qubit gates, which models the probability of error during the execution of a single-qubit gate operations (X, H).",
  "help_double_gate_err": "Specify the error rate for two-qubit gates, which models the probability of error during the execution of a two-qubit gate operation (CNOT).",
  "help_layout_method": "Choose a layout method for the transpiler to map the circuit qubits to physical qubits on the quantum hardware.",
  "help_routing_method": "Choose a routing method for the transpiler to optimize the qubit connections and minimize the errors introduced during the circuit execution.",
  "help_translation_method": "Choose a translation method for the transpiler to convert the circuit instructions into the instructions compatible with the selected backend.",
  "help_optimization_level": "Select an optimization level for the transpiler to optimize the circuit's performance by reducing the number of gates, reducing the circuit depth, or minimizing the number of SWAP gates required for qubit mapping. The higher the optimization level, the more aggressive the optimization process, which can lead to faster execution time but may also affect the circuit's accuracy.",
  "help_approximation_degree": "Specify an approximation degree for the transpiler to approximate the circuit's gates using a lower number of gates, reducing the circuit's overall complexity.",
  "help_transpiler_seed": "Seed for the stochastic parts of the transpiler.",
  "help_classical_solution": "The solution obtained by the classical algorithm which was computed using classical computation methods.",
  "help_quantum_solution": "The solution obtained by the quantum circuit which was computed using quantum computation methods",
  "help_cl_bits": "The number of classical bits used in the quantum circuit to store and process classical information. These bits are used to control the quantum operations and obtain measurement results.",
  "help_qu_bits": "The number of qubits used in the quantum circuit.",
  "help_qu_gates": "The number of elementary operations or quantum gates that were used in the experiment to implement the desired computation.",
  "help_qu_bits_cap": "The maximum number of qubits that can be used in a single experiment on this quantum computing device",
  "help_openqasm": "Download the OpenQASM code for the circuit used in the experiment.",
  "help_measurement_csv": "Download measurements of the experiment as a CSV file. The file will contain raw data from the experiment, including the binary outcome of each measurement in the order in which they were taken. The file is saved in a comma-separated value format and can be imported into spreadsheet or analysis software for further processing or visualization.",
  "help_counts_json": "Download the counts of the experiment as a JSON file. The file will contain raw data, including the counts of each measured state. Consider using this data for further analysis or visualization."
}